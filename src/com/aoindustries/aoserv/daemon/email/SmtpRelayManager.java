/*
 * Copyright 2001-2013, 2015, 2016, 2017 by AO Industries, Inc.,
 * 7262 Bull Pen Cir, Mobile, Alabama, 36695, U.S.A.
 * All rights reserved.
 */
package com.aoindustries.aoserv.daemon.email;

import com.aoindustries.aoserv.client.AOServConnector;
import com.aoindustries.aoserv.client.AOServer;
import com.aoindustries.aoserv.client.EmailSmtpRelay;
import com.aoindustries.aoserv.client.EmailSmtpRelayType;
import com.aoindustries.aoserv.client.IPAddress;
import com.aoindustries.aoserv.client.NetDevice;
import com.aoindustries.aoserv.client.OperatingSystemVersion;
import com.aoindustries.aoserv.client.Server;
import com.aoindustries.aoserv.daemon.AOServDaemon;
import com.aoindustries.aoserv.daemon.AOServDaemonConfiguration;
import com.aoindustries.aoserv.daemon.LogFactory;
import com.aoindustries.aoserv.daemon.unix.linux.PackageManager;
import com.aoindustries.aoserv.daemon.util.BuilderThread;
import com.aoindustries.aoserv.daemon.util.DaemonFileUtils;
import com.aoindustries.encoding.ChainWriter;
import com.aoindustries.io.unix.UnixFile;
import com.aoindustries.util.StringUtility;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;

/**
 * Controls access to the mail server, supports auto-expiring SMTP access.
 *
 * @author  AO Industries, Inc.
 */
public class SmtpRelayManager extends BuilderThread implements Runnable {

	private static final int REFRESH_PERIOD = 15*60*1000;

	/**
	 * sendmail configs
	 */
	private static final String ACCESS_FILENAME = "/etc/mail/access";

	/**
	 * qmail configs
	 */
	/*private static final String
		qmailFile="/etc/tcp.smtp",
		newQmailFile="/etc/tcp.smtp.new"
	;*/

	private static SmtpRelayManager smtpRelayManager;

	private static final Object rebuildLock = new Object();
	@Override
	protected boolean doRebuild() {
		try {
			AOServConnector connector=AOServDaemon.getConnector();
			AOServer thisAoServer=AOServDaemon.getThisAOServer();
			Server thisServer = thisAoServer.getServer();
			OperatingSystemVersion osv = thisServer.getOperatingSystemVersion();
			int osvId = osv.getPkey();
			if(
				osvId != OperatingSystemVersion.MANDRIVA_2006_0_I586
				&& osvId != OperatingSystemVersion.REDHAT_ES_4_X86_64
				&& osvId != OperatingSystemVersion.CENTOS_5_I686_AND_X86_64
			) throw new AssertionError("Unsupported OperatingSystemVersion: " + osv);

			int uid_min = thisAoServer.getUidMin().getId();
			int gid_min = thisAoServer.getGidMin().getId();

			EmailSmtpRelayType allowRelay=connector.getEmailSmtpRelayTypes().get(EmailSmtpRelayType.ALLOW_RELAY);
			//boolean isQmail=server.isQmail();

			// The IP addresses that have been used
			Set<String> usedHosts=new HashSet<>();

			synchronized(rebuildLock) {
				Set<UnixFile> restorecon = new LinkedHashSet<>();
				try {
					UnixFile access;
					ByteArrayOutputStream bout = new ByteArrayOutputStream();
					try (ChainWriter out = new ChainWriter(bout)) {
						/*if(isQmail) {
							access=new UnixFile(qmailFile);
							newFile=new UnixFile(newQmailFile);
						} else {*/
							// Rebuild the new config file
							out.print("# These entries were generated by ").print(SmtpRelayManager.class.getName()).print('\n');

							access=new UnixFile(ACCESS_FILENAME);
						//}

						// Allow all of the local IP addresses
						for(NetDevice nd : thisServer.getNetDevices()) {
							for(IPAddress ia : nd.getIPAddresses()) {
								String ip=ia.getInetAddress().toString();
								if(!usedHosts.contains(ip)) {
									writeAccessLine(out, ip, allowRelay/*, isQmail*/);
									usedHosts.add(ip);
								}
							}
						}

						// Deny first
						List<EmailSmtpRelay> relays = thisAoServer.getEmailSmtpRelays();
						for(EmailSmtpRelay ssr : relays) {
							if(!ssr.isDisabled()) {
								EmailSmtpRelayType esrt=ssr.getType();
								String type=esrt.getName();
								if(
									type.equals(EmailSmtpRelayType.DENY)
									|| type.equals(EmailSmtpRelayType.DENY_SPAM)
								) {
									Timestamp expiration=ssr.getExpiration();
									if(expiration==null || expiration.getTime()>System.currentTimeMillis()) {
										String host=ssr.getHost().toString();
										if(!usedHosts.contains(host)) {
											writeAccessLine(out, host, esrt/*, isQmail*/);
											usedHosts.add(host);
										}
									}
								}
							}
						}

						// Allow last
						for(EmailSmtpRelay ssr : relays) {
							if(!ssr.isDisabled()) {
								EmailSmtpRelayType esrt=ssr.getType();
								String type=esrt.getName();
								if(
									type.equals(EmailSmtpRelayType.ALLOW)
									|| type.equals(EmailSmtpRelayType.ALLOW_RELAY)
								) {
									Timestamp expiration=ssr.getExpiration();
									if(expiration==null || expiration.getTime()>System.currentTimeMillis()) {
										String host=ssr.getHost().toString();
										if(!usedHosts.contains(host)) {
											writeAccessLine(out, host, esrt/*, isQmail*/);
											usedHosts.add(host);
										}
									}
								}
							}
						}
					}
					// Write new file only when needed
					if(
						DaemonFileUtils.atomicWrite(
							access,
							bout.toByteArray(),
							0644,
							UnixFile.ROOT_UID,
							UnixFile.ROOT_GID,
							null,
							restorecon
						)
					) {
						// SELinux before makemap
						DaemonFileUtils.restorecon(restorecon);
						restorecon.clear();
						makeAccessMap();
					}
				} finally {
					DaemonFileUtils.restorecon(restorecon);
				}
			}
			return true;
		} catch(ThreadDeath TD) {
			throw TD;
		} catch(Throwable T) {
			LogFactory.getLogger(SmtpRelayManager.class).log(Level.SEVERE, null, T);
			return false;
		}
	}

	private static void writeAccessLine(ChainWriter out, String host, EmailSmtpRelayType type/*, boolean isQmail*/) throws IOException, SQLException {
		/*if(isQmail) out.print(host).print(':').print(StringUtility.replace(type.getQmailConfig(), "%h", host)).print('\n');
		else*/ out.print("Connect:").print(host).print('\t').print(StringUtility.replace(type.getSendmailConfig(), "%h", host)).print('\n');
	}
	/**
	 * Gets the number of dots in the String, returning a maximum of 3 even if there are more
	 */
	/*
	private static int getDotCount(String S) {
		int count=0;
		int len=S.length();
		for(int c=0;c<len;c++) {
			if(S.charAt(c)=='.') {
				count++;
				if(count>=3) break;
			}
		}
		return count;
	}*/

	/*private static final String[] qmailctlCdbCommand={
		"/var/qmail/bin/qmailctl",
		"cdb"
	};*/

	private static final String[] mandrivaSendmailMakemapCommand={
		"/usr/aoserv/daemon/bin/make_sendmail_access_map"
	};

	private static final String[] centosSendmailMakemapCommand={
		"/opt/aoserv-daemon/bin/make_sendmail_access_map"
	};

	private static void makeAccessMap() throws IOException, SQLException {
		String[] command;
		/*if(AOServDaemon.getThisAOServer().isQmail()) command = qmailctlCdbCommand;
		else {*/
			OperatingSystemVersion osv = AOServDaemon.getThisAOServer().getServer().getOperatingSystemVersion();
			int osvId = osv.getPkey();
			if(osvId == OperatingSystemVersion.MANDRIVA_2006_0_I586) {
				command = mandrivaSendmailMakemapCommand;
			} else if(
				osvId == OperatingSystemVersion.REDHAT_ES_4_X86_64
				|| osvId == OperatingSystemVersion.CENTOS_5_I686_AND_X86_64
			) {
				command = centosSendmailMakemapCommand;
			} else throw new AssertionError("Unsupported OperatingSystemVersion: " + osv);
		//}
		// Make sure /usr/sbin/makemap is installed as required by make_sendmail_access_map
		PackageManager.installPackage(PackageManager.PackageName.SENDMAIL);
		AOServDaemon.exec(command);
	}

	private SmtpRelayManager() {
	}

	@Override
	public void run() {
		long lastTime=Long.MIN_VALUE;
		while(true) {
			try {
				while(true) {
					try {
						Thread.sleep(REFRESH_PERIOD);
					} catch(InterruptedException err) {
						LogFactory.getLogger(SmtpRelayManager.class).log(Level.WARNING, null, err);
						// Restore the interrupted status
						Thread.currentThread().interrupt();
					}
					long time=System.currentTimeMillis();
					boolean needRebuild=false;
					for(EmailSmtpRelay relay : AOServDaemon.getThisAOServer().getEmailSmtpRelays()) {
						Timestamp expiration=relay.getExpiration();
						if(
							expiration!=null
							&& expiration.getTime()>=lastTime
							&& expiration.getTime()<time
						) {
							needRebuild=true;
							break;
						}
					}
					lastTime=time;
					if(needRebuild) doRebuild();
				}
			} catch(ThreadDeath TD) {
				throw TD;
			} catch(Throwable T) {
				LogFactory.getLogger(SmtpRelayManager.class).log(Level.SEVERE, null, T);
				try {
					Thread.sleep(REFRESH_PERIOD);
				} catch(InterruptedException err) {
					LogFactory.getLogger(SmtpRelayManager.class).log(Level.WARNING, null, err);
					// Restore the interrupted status
					Thread.currentThread().interrupt();
				}
			}
		}
	}

	public static void start() throws IOException, SQLException {
		AOServer thisAOServer = AOServDaemon.getThisAOServer();
		OperatingSystemVersion osv = thisAOServer.getServer().getOperatingSystemVersion();
		int osvId = osv.getPkey();

		synchronized(System.out) {
			if(
				// Nothing is done for these operating systems
				osvId != OperatingSystemVersion.CENTOS_5_DOM0_I686
				&& osvId != OperatingSystemVersion.CENTOS_5_DOM0_X86_64
				&& osvId != OperatingSystemVersion.CENTOS_7_DOM0_X86_64
				// Check config after OS check so config entry not needed
				&& AOServDaemonConfiguration.isManagerEnabled(SmtpRelayManager.class)
				&& smtpRelayManager == null
			) {
				System.out.print("Starting SmtpRelayManager: ");
				// Must be a supported operating system
				if(
					osvId == OperatingSystemVersion.MANDRIVA_2006_0_I586
					|| osvId == OperatingSystemVersion.REDHAT_ES_4_X86_64
					|| osvId == OperatingSystemVersion.CENTOS_5_I686_AND_X86_64
				) {
					AOServConnector conn = AOServDaemon.getConnector();
					smtpRelayManager = new SmtpRelayManager();
					conn.getEmailSmtpRelays().addTableListener(smtpRelayManager, 0);
					conn.getIpAddresses().addTableListener(smtpRelayManager, 0);
					conn.getNetDevices().addTableListener(smtpRelayManager, 0);
					new Thread(smtpRelayManager, "SmtpRelayManager").start();
					System.out.println("Done");
				} else {
					System.out.println("Unsupported OperatingSystemVersion: " + osv);
				}
			}
		}
	}

	@Override
	public String getProcessTimerDescription() {
		return "Rebuild SMTP Relays";
	}

	@Override
	public long getProcessTimerMaximumTime() {
		return (long)30*60*1000;
	}
}
