/*
 * Copyright 2001-2013, 2015, 2016, 2017 by AO Industries, Inc.,
 * 7262 Bull Pen Cir, Mobile, Alabama, 36695, U.S.A.
 * All rights reserved.
 */
package com.aoindustries.aoserv.daemon.net.ssh;

import com.aoindustries.aoserv.client.AOServConnector;
import com.aoindustries.aoserv.client.AOServer;
import com.aoindustries.aoserv.client.NetBind;
import com.aoindustries.aoserv.client.OperatingSystemVersion;
import com.aoindustries.aoserv.client.Protocol;
import com.aoindustries.aoserv.daemon.AOServDaemon;
import com.aoindustries.aoserv.daemon.AOServDaemonConfiguration;
import com.aoindustries.aoserv.daemon.LogFactory;
import com.aoindustries.aoserv.daemon.unix.linux.PackageManager;
import com.aoindustries.aoserv.daemon.util.BuilderThread;
import com.aoindustries.encoding.ChainWriter;
import com.aoindustries.io.unix.UnixFile;
import com.aoindustries.net.AddressFamily;
import com.aoindustries.net.InetAddress;
import com.aoindustries.net.Port;
import com.aoindustries.selinux.SEManagePort;
import com.aoindustries.util.WrappedException;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.logging.Level;

/**
 * Handles the building of SSHD configs and files.
 */
final public class SshdManager extends BuilderThread {

	/**
	 * The default SSH port.
	 */
	private static final int DEFAULT_PORT = 22;

	/**
	 * The value for MaxStartups.
	 */
	private static final String MAX_STARTUPS = "60:30:100";

	/**
	 * The SELinux type for the SSH daemon.
	 */
	private static final String SELINUX_TYPE = "ssh_port_t";

	/**
	 * Nine years ago we submitted a patch to eliminate the build-time limit on the number
	 * of ListenAddress allowed in <code>sshd_config</code>.  We just tested CentOS 7 and
	 * this limit still remains.
	 * <p>
	 * Software should just do what it's told without arbitrary compile-time limits, but
	 * this is out of our control.
	 * </p>
	 * <p>
	 * Our use-case has changed as we move away from large shared servers into smaller
	 * focused Xen-based virtual servers.  As such, we are no longer packing tons of
	 * different IPs into single servers.
	 * </p>
	 * <p>
	 * Rather than continue building our own customized SSH RPM, we will simply refuse to
	 * build any config file with more than 16 <code>net_binds</code>.
	 * </p>
	 */
	private static final int MAX_LISTEN_SOCKS = 16; // Matches the value defined in sshd.c

	private static SshdManager sshdManager;

	private SshdManager() {
	}

	private static void writeListenAddresses(Collection<? extends NetBind> nbs, ChainWriter out) throws SQLException, IOException {
		if(nbs.isEmpty()) {
			// Restore defaults
			out.print("#ListenAddress 0.0.0.0\n"
					+ "#ListenAddress ::\n");
		} else {
			for(NetBind nb : nbs) {
				out.print("ListenAddress ");
				InetAddress ip = nb.getIPAddress().getInetAddress();
				AddressFamily addressFamily = ip.getAddressFamily();
				switch(addressFamily) {
					case INET :
						out.print(ip.toString());
						break;
					case INET6 :
						out.print('[').print(ip.toString()).print(']');
						break;
					default :
						throw new AssertionError("Unexpected address family: " + addressFamily);
				}
				int port = nb.getPort().getPort();
				if(port != DEFAULT_PORT) {
					out.print(':').print(port);
				}
				out.print("\n");
			}
		}
	}

	/**
	 * Builds the config file for CentOS 5.
	 */
	private static void writeConfigFileCentOS5(Collection<? extends NetBind> nbs, ChainWriter out) throws SQLException, IOException {
		out.print("#\n"
				+ "# This configuration file is automatically generated by\n"
				+ "# ").print(SshdManager.class.getName()).print("\n"
				+ "#\n"
				+ "Port " + DEFAULT_PORT + "\n"
				+ "Protocol 2\n");
				// Changed to not allow Protocol 1 on 2005-02-01 by Dan Armstrong
				//+ "Protocol 2,1\n");
		writeListenAddresses(nbs, out);
		out.print("AcceptEnv SCREEN_SESSION\n"
				+ "SyslogFacility AUTHPRIV\n"
				+ "PermitRootLogin yes\n"
				+ "PasswordAuthentication yes\n"
				+ "ChallengeResponseAuthentication no\n"
				+ "GSSAPIAuthentication yes\n"
				+ "GSSAPICleanupCredentials yes\n"
				+ "UsePAM yes\n"
				+ "AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES\n"
				+ "AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT\n"
				+ "AcceptEnv LC_IDENTIFICATION LC_ALL\n"
				+ "MaxStartups " + MAX_STARTUPS + "\n"
				+ "X11Forwarding yes\n"
				+ "UsePrivilegeSeparation yes\n"
				+ "Subsystem sftp /usr/libexec/openssh/sftp-server\n"
		);
	}

	/**
	 * Builds the config file for CentOS 7.
	 */
	private static void writeConfigFileCentOS7(Collection<? extends NetBind> nbs, ChainWriter out) throws SQLException, IOException {
		out.print("#\n"
				+ "# This configuration file is automatically generated by\n"
				+ "# ").print(SshdManager.class.getName()).print("\n"
				+ "#\n"
				+ "\n"
				+ "#\t$OpenBSD: sshd_config,v 1.93 2014/01/10 05:59:19 djm Exp $\n"
				+ "\n"
				+ "# This is the sshd server system-wide configuration file.  See\n"
				+ "# sshd_config(5) for more information.\n"
				+ "\n"
				+ "# This sshd was compiled with PATH=/usr/local/bin:/usr/bin\n"
				+ "\n"
				+ "# The strategy used for options in the default sshd_config shipped with\n"
				+ "# OpenSSH is to specify options with their default value where\n"
				+ "# possible, but leave them commented.  Uncommented options override the\n"
				+ "# default value.\n"
				+ "\n"
				+ "# If you want to change the port on a SELinux system, you have to tell\n"
				+ "# SELinux about this change.\n"
				+ "# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER\n"
				+ "#\n"
				+ "Port " + DEFAULT_PORT + "\n");
		if(nbs.isEmpty()) {
			// Restore to default settigs before disabling service
			out.print("#AddressFamily any\n");
		} else {
			// Determine address family
			boolean hasIPv4 = false;
			boolean hasIPv6 = false;
			LOOP :
			for(NetBind nb : nbs) {
				InetAddress ip = nb.getIPAddress().getInetAddress();
				AddressFamily addressFamily = ip.getAddressFamily();
				switch(addressFamily) {
					case INET :
						hasIPv4 = true;
						if(hasIPv6) break LOOP;
						break;
					case INET6 :
						hasIPv6 = true;
						if(hasIPv4) break LOOP;
						break;
					default :
						throw new AssertionError("Unexpected address family: " + addressFamily);
				}
			}
			out.print("AddressFamily ");
			if(hasIPv4 && hasIPv6) {
				out.print("any"); // Both IPv4 and IPv6
			} else if(hasIPv4) {
				out.print("inet"); // IPv4 only
			} else if(hasIPv6) {
				out.print("inet6"); // IPv6 only
			} else {
				throw new AssertionError();
			}
			out.print('\n');
		}
		writeListenAddresses(nbs, out);
		out.print("\n"
				+ "# The default requires explicit activation of protocol 1\n"
				+ "#Protocol 2\n"
				+ "\n"
				+ "# HostKey for protocol version 1\n"
				+ "#HostKey /etc/ssh/ssh_host_key\n"
				+ "# HostKeys for protocol version 2\n"
				+ "HostKey /etc/ssh/ssh_host_rsa_key\n"
				+ "#HostKey /etc/ssh/ssh_host_dsa_key\n"
				+ "HostKey /etc/ssh/ssh_host_ecdsa_key\n"
				+ "HostKey /etc/ssh/ssh_host_ed25519_key\n"
				+ "\n"
				+ "# Lifetime and size of ephemeral version 1 server key\n"
				+ "#KeyRegenerationInterval 1h\n"
				+ "#ServerKeyBits 1024\n"
				+ "\n"
				+ "# Ciphers and keying\n"
				+ "#RekeyLimit default none\n"
				+ "\n"
				+ "# Logging\n"
				+ "# obsoletes QuietMode and FascistLogging\n"
				+ "#SyslogFacility AUTH\n"
				+ "SyslogFacility AUTHPRIV\n"
				+ "#LogLevel INFO\n"
				+ "\n"
				+ "# Authentication:\n"
				+ "\n"
				+ "#LoginGraceTime 2m\n"
			// TODO: When there is at least one non-disabled sudoer, should this be automatically set to "no"?
				+ "#PermitRootLogin yes\n"
				+ "#StrictModes yes\n"
				+ "#MaxAuthTries 6\n"
				+ "#MaxSessions 10\n"
				+ "\n"
				+ "#RSAAuthentication yes\n"
				+ "#PubkeyAuthentication yes\n"
				+ "\n"
				+ "# The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2\n"
				+ "# but this is overridden so installations will only check .ssh/authorized_keys\n"
				+ "AuthorizedKeysFile\t.ssh/authorized_keys\n"
				+ "\n"
				+ "#AuthorizedPrincipalsFile none\n"
				+ "\n"
				+ "#AuthorizedKeysCommand none\n"
				+ "#AuthorizedKeysCommandUser nobody\n"
				+ "\n"
				+ "# For this to work you will also need host keys in /etc/ssh/ssh_known_hosts\n"
				+ "#RhostsRSAAuthentication no\n"
				+ "# similar for protocol version 2\n"
				+ "#HostbasedAuthentication no\n"
				+ "# Change to yes if you don't trust ~/.ssh/known_hosts for\n"
				+ "# RhostsRSAAuthentication and HostbasedAuthentication\n"
				+ "#IgnoreUserKnownHosts no\n"
				+ "# Don't read the user's ~/.rhosts and ~/.shosts files\n"
				+ "#IgnoreRhosts yes\n"
				+ "\n"
				+ "# To disable tunneled clear text passwords, change to no here!\n"
				+ "#PasswordAuthentication yes\n"
				+ "#PermitEmptyPasswords no\n"
				+ "PasswordAuthentication yes\n"
				+ "\n"
				+ "# Change to no to disable s/key passwords\n"
				+ "#ChallengeResponseAuthentication yes\n"
				+ "ChallengeResponseAuthentication no\n"
				+ "\n"
				+ "# Kerberos options\n"
				+ "#KerberosAuthentication no\n"
				+ "#KerberosOrLocalPasswd yes\n"
				+ "#KerberosTicketCleanup yes\n"
				+ "#KerberosGetAFSToken no\n"
				+ "#KerberosUseKuserok yes\n"
				+ "\n"
				+ "# GSSAPI options\n"
				+ "GSSAPIAuthentication yes\n"
				+ "GSSAPICleanupCredentials no\n"
				+ "#GSSAPIStrictAcceptorCheck yes\n"
				+ "#GSSAPIKeyExchange no\n"
				+ "#GSSAPIEnablek5users no\n"
				+ "\n"
				+ "# Set this to 'yes' to enable PAM authentication, account processing,\n"
				+ "# and session processing. If this is enabled, PAM authentication will\n"
				+ "# be allowed through the ChallengeResponseAuthentication and\n"
				+ "# PasswordAuthentication.  Depending on your PAM configuration,\n"
				+ "# PAM authentication via ChallengeResponseAuthentication may bypass\n"
				+ "# the setting of \"PermitRootLogin without-password\".\n"
				+ "# If you just want the PAM account and session checks to run without\n"
				+ "# PAM authentication, then enable this but set PasswordAuthentication\n"
				+ "# and ChallengeResponseAuthentication to 'no'.\n"
				+ "# WARNING: 'UsePAM no' is not supported in Red Hat Enterprise Linux and may cause several\n"
				+ "# problems.\n"
				+ "UsePAM yes\n"
				+ "\n"
				+ "#AllowAgentForwarding yes\n"
				+ "#AllowTcpForwarding yes\n"
				// We had on suspendo.aoindustries.com: GatewayPorts clientspecified
				+ "#GatewayPorts no\n"
				+ "X11Forwarding yes\n"
				+ "#X11DisplayOffset 10\n"
				+ "#X11UseLocalhost yes\n"
				+ "#PermitTTY yes\n"
				+ "#PrintMotd yes\n"
				+ "#PrintLastLog yes\n"
				+ "#TCPKeepAlive yes\n"
				+ "#UseLogin no\n"
				+ "UsePrivilegeSeparation sandbox\t\t# Default for new installations.\n"
				+ "#PermitUserEnvironment no\n"
				+ "#Compression delayed\n"
				+ "#ClientAliveInterval 0\n"
				+ "#ClientAliveCountMax 3\n"
				+ "#ShowPatchLevel no\n"
				+ "#UseDNS yes\n"
				+ "#PidFile /var/run/sshd.pid\n"
				+ "MaxStartups " + MAX_STARTUPS + "\n"
				+ "#PermitTunnel no\n"
				+ "#ChrootDirectory none\n"
				+ "#VersionAddendum none\n"
				+ "\n"
				+ "# no default banner path\n"
				+ "#Banner none\n"
				+ "\n"
				+ "# Accept locale-related environment variables\n"
				+ "AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES\n"
				+ "AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT\n"
				+ "AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE\n"
				+ "AcceptEnv XMODIFIERS\n"
				+ "\n"
				+ "# Accept variable for auto-screen\n"
				+ "AcceptEnv SCREEN_SESSION\n"
				+ "\n"
				+ "# override default of no subsystems\n"
				+ "Subsystem\tsftp\t/usr/libexec/openssh/sftp-server\n"
				+ "\n"
				+ "# Example of overriding settings on a per-user basis\n"
				+ "#Match User anoncvs\n"
				+ "#\tX11Forwarding no\n"
				+ "#\tAllowTcpForwarding no\n"
				+ "#\tPermitTTY no\n"
				+ "#\tForceCommand cvs server\n"
		);
	}

	private static final Object rebuildLock = new Object();
	@Override
	protected boolean doRebuild() {
		try {
			AOServer thisAoServer = AOServDaemon.getThisAOServer();
			OperatingSystemVersion osv = thisAoServer.getServer().getOperatingSystemVersion();
			int osvId = osv.getPkey();

			int uid_min = thisAoServer.getUidMin().getId();
			int gid_min = thisAoServer.getGidMin().getId();


			AOServConnector conn = AOServDaemon.getConnector();
			synchronized(rebuildLock) {
				// Find all the ports that should be bound to
				List<NetBind> nbs = new ArrayList<>();
				boolean hasSpecificAddress = false;
				{
					Protocol sshProtocol = conn.getProtocols().get(Protocol.SSH);
					if(sshProtocol == null) throw new SQLException("Protocol not found: " + Protocol.SSH);
					for(NetBind nb : thisAoServer.getServer().getNetBinds(sshProtocol)) {
						if(nb.getNetTcpRedirect() == null) {
							com.aoindustries.net.Protocol netProtocol = nb.getPort().getProtocol();
							if(netProtocol != com.aoindustries.net.Protocol.TCP) {
								throw new IOException("Unsupported protocol for SSH: " + netProtocol);
							}
							nbs.add(nb);
							if(!nb.getIPAddress().getInetAddress().isUnspecified()) hasSpecificAddress = true;
						}
					}
				}
				if(nbs.size() > MAX_LISTEN_SOCKS) {
					throw new IOException("Refusing to build sshd_config with more than MAX_LISTEN_SOCKS(" + MAX_LISTEN_SOCKS + ") ListenAddress directives: " + nbs.size());
				}
				// Restart only when something changed
				boolean[] needsRestart = {false};
				// Install openssh-server package if missing (when there is at least one port)
				if(!nbs.isEmpty()) {
					PackageManager.installPackage(
						PackageManager.PackageName.OPENSSH_SERVER,
						() -> {
							// Enable service after package installation
							try {
								if(osvId == OperatingSystemVersion.CENTOS_5_I686_AND_X86_64) {
									AOServDaemon.exec("/sbin/chkconfig", "sshd", "on");
								} else if(osvId == OperatingSystemVersion.CENTOS_7_X86_64) {
									AOServDaemon.exec("/usr/bin/systemctl", "enable", "sshd");
								} else throw new AssertionError("Unsupported OperatingSystemVersion: " + osv);
							} catch(IOException e) {
								throw new WrappedException(e);
							}
							needsRestart[0] = true;
						}
					);
					// Install aoserv-sshd-config package on CentOS 7 when needed
					if(hasSpecificAddress && osvId == OperatingSystemVersion.CENTOS_7_X86_64) {
						PackageManager.installPackage(PackageManager.PackageName.AOSERV_SSHD_CONFIG);
					}
				}
				boolean isSshInstalled = PackageManager.getInstalledPackage(PackageManager.PackageName.OPENSSH_SERVER) != null;
				if(!nbs.isEmpty() && !isSshInstalled) throw new AssertionError(PackageManager.PackageName.OPENSSH_SERVER + " not installed");
				// Write/rewrite config when ssh server installed
				if(isSshInstalled) {
					// If there are not SSH ports, this will still build the config if the SSH daemon is installed.
					// In this case, the SSH daemon will be configured with no ListenAddress, which will default to
					// listening on all IPs should sshd be re-enable by the administrator.

					// Build the new config file to RAM
					byte[] newConfig;
					{
						ByteArrayOutputStream bout = new ByteArrayOutputStream();
						try (ChainWriter out = new ChainWriter(bout)) {
							if(osvId == OperatingSystemVersion.CENTOS_5_I686_AND_X86_64) {
								writeConfigFileCentOS5(nbs, out);
							} else if(osvId == OperatingSystemVersion.CENTOS_7_X86_64) {
								writeConfigFileCentOS7(nbs, out);
							} else {
								throw new AssertionError("Unsupported OperatingSystemVersion: " + osv);
							}
						}
						newConfig = bout.toByteArray();
					}

					// Write the new file only when file changed
					UnixFile configFile = new UnixFile("/etc/ssh/sshd_config");
					if(
						!configFile.getStat().exists()
						|| !configFile.contentEquals(newConfig)
					) {
						// Write to temp file
						UnixFile newConfigFile = new UnixFile("/etc/ssh/sshd_config.new");
						try (OutputStream newConfigOut = newConfigFile.getSecureOutputStream(UnixFile.ROOT_UID, UnixFile.ROOT_GID, 0600, true, uid_min, gid_min)) {
							newConfigOut.write(newConfig);
						}

						// Atomically move into place
						newConfigFile.renameTo(configFile);

						needsRestart[0] = true;
					}
				}
				// Manage SELinux:
				if(osvId == OperatingSystemVersion.CENTOS_5_I686_AND_X86_64) {
					// SELinux left in Permissive state, not configured here
				} else if(osvId == OperatingSystemVersion.CENTOS_7_X86_64) {
					// Note: SELinux configuration exists even without the openssh-server package installed.
					//       SELinux policies are provided independent of specific packages.
					//       Thus, we manage this even when the server not installed.

					// See https://bugzilla.redhat.com/show_bug.cgi?id=653579
					// Install /usr/bin/semanage if missing
					PackageManager.installPackage(PackageManager.PackageName.POLICYCOREUTILS_PYTHON);
					// Find the set of distinct ports used by SSH server
					SortedSet<Port> sshPorts = new TreeSet<>();
					for(NetBind nb : nbs) {
						sshPorts.add(nb.getPort());
					}
					// Reconfigure SELinux ports
					if(SEManagePort.configure(sshPorts, SELINUX_TYPE)) {
						needsRestart[0] = true;
					}
				} else throw new AssertionError("Unsupported OperatingSystemVersion: " + osv);

				// Stop / restart after SELinux changes so ports may be opened
				if(isSshInstalled) {
					if(nbs.isEmpty()) {
						// Disable and shutdown service since there are no net_binds
						// openssh-server RPM is left installed
						if(osvId == OperatingSystemVersion.CENTOS_5_I686_AND_X86_64) {
							AOServDaemon.exec("/sbin/chkconfig", "sshd", "off");
							AOServDaemon.exec("/etc/rc.d/init.d/sshd", "stop");
						} else if(osvId == OperatingSystemVersion.CENTOS_7_X86_64) {
							AOServDaemon.exec("/usr/bin/systemctl", "disable", "sshd");
							AOServDaemon.exec("/usr/bin/systemctl", "stop", "sshd");
						} else throw new AssertionError("Unsupported OperatingSystemVersion: " + osv);
					} else if(needsRestart[0]) {
						if(osvId == OperatingSystemVersion.CENTOS_5_I686_AND_X86_64) {
							// Try reload config first
							try {
								AOServDaemon.exec(
									"/etc/rc.d/init.d/sshd",
									"reload"
								);
							} catch(IOException err) {
								LogFactory.getLogger(this.getClass()).log(Level.SEVERE, null, err);

								// Try more forceful stop/start
								try {
									AOServDaemon.exec(
										"/etc/rc.d/init.d/sshd",
										"stop"
									);
								} catch(IOException err2) {
									LogFactory.getLogger(this.getClass()).log(Level.SEVERE, null, err2);
								}
								try {
									Thread.sleep(1000);
								} catch(InterruptedException err2) {
									LogFactory.getLogger(this.getClass()).log(Level.WARNING, null, err2);
									// Restore the interrupted status
									Thread.currentThread().interrupt();
								}
								AOServDaemon.exec(
									"/etc/rc.d/init.d/sshd",
									"start"
								);
							}
						} else if(osvId == OperatingSystemVersion.CENTOS_7_X86_64) {
							AOServDaemon.exec("/usr/bin/systemctl", "enable", "sshd");
							// TODO: Should this be reload-or-restart?
							AOServDaemon.exec("/usr/bin/systemctl", "restart", "sshd");
						} else throw new AssertionError("Unsupported OperatingSystemVersion: " + osv);
					}
				}
				// Uninstall aoserv-sshd-config package on CentOS 7 when not needed
				if(
					!hasSpecificAddress
					&& osvId == OperatingSystemVersion.CENTOS_7_X86_64
					&& AOServDaemonConfiguration.isPackageManagerUninstallEnabled()
				) {
					PackageManager.removePackage(PackageManager.PackageName.AOSERV_SSHD_CONFIG);
				}
			}
			return true;
		} catch(ThreadDeath TD) {
			throw TD;
		} catch(Throwable T) {
			LogFactory.getLogger(SshdManager.class).log(Level.SEVERE, null, T);
			return false;
		}
	}

	public static void start() throws IOException, SQLException {
		AOServer thisAOServer = AOServDaemon.getThisAOServer();
		OperatingSystemVersion osv = thisAOServer.getServer().getOperatingSystemVersion();
		int osvId = osv.getPkey();

		synchronized(System.out) {
			if(
				// Nothing is done for these operating systems
				osvId != OperatingSystemVersion.CENTOS_5_DOM0_I686
				&& osvId != OperatingSystemVersion.CENTOS_5_DOM0_X86_64
				&& osvId != OperatingSystemVersion.CENTOS_7_DOM0_X86_64
				// Check config after OS check so config entry not needed
				&& AOServDaemonConfiguration.isManagerEnabled(SshdManager.class)
				&& sshdManager == null
			) {
				System.out.print("Starting SshdManager: ");
				// Must be a supported operating system
				if(
					osvId == OperatingSystemVersion.CENTOS_5_I686_AND_X86_64
					|| osvId == OperatingSystemVersion.CENTOS_7_X86_64
				) {
					AOServConnector conn = AOServDaemon.getConnector();
					sshdManager = new SshdManager();
					conn.getNetBinds().addTableListener(sshdManager, 0);
					System.out.println("Done");
				} else {
					System.out.println("Unsupported OperatingSystemVersion: " + osv);
				}
			}
		}
	}

	@Override
	public String getProcessTimerDescription() {
		return "Rebuild SSH Configuration";
	}
}
