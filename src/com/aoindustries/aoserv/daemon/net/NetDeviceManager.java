package com.aoindustries.aoserv.daemon.net;

import com.aoindustries.aoserv.client.*;
import com.aoindustries.aoserv.daemon.*;
import com.aoindustries.aoserv.daemon.util.*;
import com.aoindustries.io.*;
import com.aoindustries.io.unix.*;
import com.aoindustries.profiler.*;
import com.aoindustries.table.*;
import com.aoindustries.util.*;
import java.io.*;
import java.sql.*;
import java.util.*;

/**
 * Handles the building of IP address configs and files.
 */
final public class NetDeviceManager extends BuilderThread {
    
    public static final UnixFile
        netScriptDirectory=new UnixFile("/etc/sysconfig/network-scripts"),
        networkScript=new UnixFile("/etc/sysconfig/network"),
        networkScriptNew=new UnixFile("/etc/sysconfig/network.new")
    ;
    
    private static NetDeviceManager netDeviceManager;
    
    private NetDeviceManager() {
        Profiler.startProfile(Profiler.INSTANTANEOUS, NetDeviceManager.class, "<init>()", null);
        Profiler.endProfile(Profiler.INSTANTANEOUS);
    }
    
    private static final Object rebuildLock=new Object();
    protected void doRebuild() throws IOException, SQLException {
        Profiler.startProfile(Profiler.UNKNOWN, NetDeviceManager.class, "doRebuild()", null);
        try {
            AOServConnector connector=AOServDaemon.getConnector();
            AOServer thisAOServer=AOServDaemon.getThisAOServer();
            
            int osv=thisAOServer.getServer().getOperatingSystemVersion().getPkey();
            if(
                osv!=OperatingSystemVersion.MANDRAKE_10_1_I586
            ) throw new SQLException("Unsupported OperatingSystemVersion: "+osv);
            
            final Stat tempStat = new Stat();

            synchronized(rebuildLock) {
                List<NetDeviceID> restartDeviceIDs=new SortedArrayList<NetDeviceID>();
                
                List<NetDevice> devices=thisAOServer.getNetDevices();
                for(int c=0;c<devices.size();c++) {
                    NetDevice device=devices.get(c);
                    NetDeviceID deviceId=device.getNetDeviceID();
                    if(!deviceId.isLoopback()) {
                        // Build the new primary IP script
                        UnixFile cfgFile=new UnixFile(netScriptDirectory, "ifcfg-"+deviceId+".new", false);
                        ChainWriter out=new ChainWriter(
                            new BufferedOutputStream(
                                cfgFile.getSecureOutputStream(UnixFile.ROOT_UID, UnixFile.ROOT_GID, 0600, true)
                            )
                        );
                        try {
                            if(osv==OperatingSystemVersion.MANDRAKE_10_1_I586) {
                                out.print("#\n"
                                + "# Automatically generated by ").print(NetDeviceManager.class.getName()).print("\n"
                                + "#\n"
                                + "DEVICE=").print(deviceId).print('\n');
                                String macAddr=device.getMacAddress();
                                if(macAddr!=null) out.print("MACADDR=").print(macAddr).print('\n');
                                IPAddress primaryIP=device.getPrimaryIPAddress();
                                if(primaryIP.isDHCP()) {
                                    out.print("BOOTPROTO=dhcp\n"
                                            + "ONBOOT=yes\n"
                                            + "NEEDHOSTNAME=no\n"
                                            + "MII_NOT_SUPPORTED=yes\n");
                                } else {
                                    String network=device.getNetwork();
                                    if(network==null) throw new SQLException("(net_devices.pkey="+device.getPkey()+").network may not be null");
                                    String broadcast=device.getBroadcast();
                                    if(broadcast==null) throw new SQLException("(net_devices.pkey="+device.getPkey()+").broadcast may not be null");
                                    out.print("BOOTPROTO=static\n"
                                            + "IPADDR=").print(primaryIP.getIPAddress()).print("\n"
                                            + "NETMASK=").print(device.getNetMask()).print("\n"
                                            + "NETWORK=").print(network).print("\n"
                                            + "BROADCAST=").print(broadcast).print("\n"
                                            + "ONBOOT=yes\n"
                                            + "MII_NOT_SUPPORTED=yes\n");
                                }
                            } else throw new SQLException("Unsupported OperatingSystemVersion: "+osv);
                        } finally {
                            out.flush();
                            out.close();
                        }
                        UnixFile existing=new UnixFile(netScriptDirectory, "ifcfg-"+deviceId, false);
                        if(!existing.getStat(tempStat).exists() || !cfgFile.contentEquals(existing)) {
                            cfgFile.renameTo(existing);
                            if(!restartDeviceIDs.contains(deviceId)) restartDeviceIDs.add(deviceId);
                        } else cfgFile.delete();
                        
                        // Rebuild the alias configs for this server, including all child failed-over servers IPs
                        List<String> cfgFilenames=new SortedArrayList<String>();
                        String aliasBeginning="ifcfg-"+deviceId+":";
                        int num=0;
                        List<AOServer> children=thisAOServer.getNestedAOServers();
                        for(int d=-1;d<children.size();d++) {
                            AOServer server=d==-1?thisAOServer:children.get(d).getServer().getAOServer();
                            NetDevice curDevice=d==-1?device:server.getNetDevice(device.getNetDeviceID().getName());
                            if(curDevice!=null) {
                                List<IPAddress> ips=curDevice.getIPAddresses();
                                for(int e=0;e<ips.size();e++) {
                                    IPAddress ip=ips.get(e);
                                    if(d!=-1 || ip.isAlias()) {
                                        if(ip.isDHCP()) throw new SQLException("DHCP IP Aliases are not allowed for IPAddress #"+ip.getPkey());
                                        
                                        String filename=aliasBeginning+(num++);
                                        cfgFilenames.add(filename);
                                        UnixFile newCfgUF=new UnixFile(netScriptDirectory, filename+".new", false);
                                        out=new ChainWriter(
                                            new BufferedOutputStream(
                                                newCfgUF.getSecureOutputStream(
                                                    UnixFile.ROOT_UID,
                                                    UnixFile.ROOT_GID,
                                                    0600,
                                                    true
                                                )
                                            )
                                        );
                                        try {
                                            out.print("#\n"
                                                    + "# Automatically generated by ").print(NetDeviceManager.class.getName()).print("\n"
                                                    + "#\n");
                                            if(osv==OperatingSystemVersion.MANDRAKE_10_1_I586) {
                                                out.print("IPADDR=").print(ip.getIPAddress()).print("\n"
                                                        + "NETMASK=").print(curDevice.getNetMask()).print("\n");
                                            } else throw new SQLException("Unsupported OperatingSystemVersion: "+osv);
                                        } finally {
                                            out.flush();
                                            out.close();
                                        }
                                        
                                        UnixFile cfgUF=new UnixFile(netScriptDirectory, filename, false);
                                        if(!cfgUF.getStat(tempStat).exists() || !newCfgUF.contentEquals(cfgUF)) {
                                            if(!newCfgUF.getFile().renameTo(cfgUF.getFile())) throw new IOException("Unable to move "+newCfgUF.getFilename()+" to "+cfgUF.getFilename());
                                            if(!restartDeviceIDs.contains(deviceId)) restartDeviceIDs.add(deviceId);
                                        } else newCfgUF.delete();
                                    }
                                }
                            }
                        }
                        
                        // Remove the extra alias configs
                        String[] list=netScriptDirectory.list();
                        for(int d=0;d<list.length;d++) {
                            String filename=list[d];
                            if(
                            !cfgFilenames.contains(filename)
                            && filename.length()>aliasBeginning.length()
                            && filename.substring(0, aliasBeginning.length()).equals(aliasBeginning)
                            ) {
                                UnixFile extra=new UnixFile(netScriptDirectory, filename, false);
                                extra.delete();
                                if(!restartDeviceIDs.contains(deviceId)) restartDeviceIDs.add(deviceId);
                            }
                        }
                    }
                }
                
                // On Mandrake 10.1, also rebuild the /etc/sysconfig/network file
                if(
                    osv==OperatingSystemVersion.MANDRAKE_10_1_I586
                ) {
                    ChainWriter out=new ChainWriter(
                    new BufferedOutputStream(
                    networkScriptNew.getSecureOutputStream(UnixFile.ROOT_UID, UnixFile.ROOT_GID, 0755, true)
                    )
                    );
                    try {
                        out.print("#\n"
                        + "# Automatically generated by ").print(NetDeviceManager.class.getName()).print("\n"
                        + "#\n"
                        + "HOSTNAME=").print(thisAOServer.getHostname()).print("\n"
                        + "NETWORKING=yes\n");
                        // There should no more than one network device with a gateway specified
                        List<NetDevice> gatewayDevices=new ArrayList<NetDevice>();
                        for(int c=0;c<devices.size();c++) {
                            NetDevice device=devices.get(c);
                            NetDeviceID deviceId=device.getNetDeviceID();
                            if(!deviceId.isLoopback()) {
                                if(device.getGateway()!=null) gatewayDevices.add(device);
                            }
                        }
                        if(gatewayDevices.size()>0) {
                            if(gatewayDevices.size()>1) throw new SQLException("More than one gateway device found: "+gatewayDevices.size());
                            NetDevice gateway=gatewayDevices.get(0);
                            out.print("GATEWAY=").print(gateway.getGateway()).print("\n"
                            + "GATEWAYDEV=").print(gateway.getNetDeviceID().getName()).print('\n');
                        }
                    } finally {
                        out.flush();
                        out.close();
                    }
                    if(!networkScript.getStat(tempStat).exists() || !networkScriptNew.contentEquals(networkScript)) {
                        networkScriptNew.renameTo(networkScript);
                        // Restart all devices in this scenario
                        for(int c=0;c<devices.size();c++) {
                            NetDeviceID deviceId=devices.get(c).getNetDeviceID();
                            if(!restartDeviceIDs.contains(deviceId)) restartDeviceIDs.add(deviceId);
                        }
                    } else networkScriptNew.delete();
                }
                
                // Do not restart devices when is nested or in failover, the parent server does this
                if(!AOServDaemonConfiguration.isNested() && thisAOServer.getFailoverServer()==null) {
                    try {
                        for(int c=0;c<restartDeviceIDs.size();c++) {
                            // Restart the networking
                            NetDeviceID deviceId=restartDeviceIDs.get(c);
                            Process P=Runtime.getRuntime().exec(new String[] {"/sbin/ifdown", deviceId.getName()});
                            int downCode;
                            try {
                                P.getOutputStream().close();
                                downCode=P.waitFor();
                            } catch(InterruptedException err) {
                                downCode=-1;
                            }
                            P=Runtime.getRuntime().exec(new String[] {"/sbin/ifup", deviceId.getName()});
                            int upCode;
                            try {
                                P.getOutputStream().close();
                                upCode=P.waitFor();
                            } catch(InterruptedException err) {
                                upCode=-1;
                            }
                            if(downCode!=0) throw new IOException("Error calling /sbin/ifdown "+deviceId+", retCode="+(downCode==-1?"Interrupted":Integer.toString(downCode)));
                            if(upCode!=0) throw new IOException("Error calling /sbin/ifup "+deviceId+", retCode="+(upCode==-1?"Interrupted":Integer.toString(upCode)));
                        }
                    } finally {
                        if(restartDeviceIDs.size()>0) {
                            Process P=Runtime.getRuntime().exec(new String[] {"/etc/aoserv/daemon/route", "start"});
                            int routeCode;
                            try {
                                P.getOutputStream().close();
                                routeCode=P.waitFor();
                            } catch(InterruptedException err) {
                                routeCode=-1;
                            }
                            if(routeCode!=0) throw new IOException("Error calling /etc/aoserv/daemon/route start, retCode="+(routeCode==-1?"Interrupted":Integer.toString(routeCode)));
                        }
                    }
                }
            }
        } finally {
            Profiler.endProfile(Profiler.UNKNOWN);
        }
    }
    
    public static void start() throws IOException, SQLException {
        Profiler.startProfile(Profiler.UNKNOWN, NetDeviceManager.class, "start()", null);
        try {
            if(AOServDaemonConfiguration.isManagerEnabled(NetDeviceManager.class) && netDeviceManager==null) {
                synchronized(System.out) {
                    if(netDeviceManager==null) {
                        System.out.print("Starting NetDeviceManager: ");
                        AOServConnector conn=AOServDaemon.getConnector();
                        netDeviceManager=new NetDeviceManager();
                        conn.ipAddresses.addTableListener(netDeviceManager, 0);
                        conn.netDevices.addTableListener(netDeviceManager, 0);
                        System.out.println("Done");
                    }
                }
            }
        } finally {
            Profiler.endProfile(Profiler.UNKNOWN);
        }
    }
    
    public String getProcessTimerDescription() {
        Profiler.startProfile(Profiler.INSTANTANEOUS, NetDeviceManager.class, "getProcessTimerDescription()", null);
        try {
            return "Rebuild Net Devices";
        } finally {
            Profiler.endProfile(Profiler.INSTANTANEOUS);
        }
    }

    public static String getNetDeviceBondingReport(NetDevice netDevice) throws IOException, SQLException {
        Profiler.startProfile(Profiler.UNKNOWN, NetDeviceManager.class, "getNetDeviceBondingReport(NetDevice)", null);
        try {
            File procFile;
            int osv = AOServDaemon.getThisAOServer().getServer().getOperatingSystemVersion().getPkey();
            if(
                osv==OperatingSystemVersion.CENTOS_5DOM0_I686
                || osv==OperatingSystemVersion.CENTOS_5DOM0_X86_64
            ) {
                // Xen adds a "p" to the name
                procFile = new File("/proc/net/bonding/p"+netDevice.getNetDeviceID().getName());
            } else {
                procFile = new File("/proc/net/bonding/"+netDevice.getNetDeviceID().getName());
            }
            String report;
            if(procFile.exists()) {
		StringBuilder SB=new StringBuilder();
                InputStream in=new BufferedInputStream(new FileInputStream(procFile));
		try {
		    int ch;
		    while((ch=in.read())!=-1) SB.append((char)ch);
		} finally {
		    in.close();
		}
                report = SB.toString();
            } else report="";
            return report;
        } finally {
            Profiler.endProfile(Profiler.UNKNOWN);
        }
    }
}
