/*
 * aoserv-daemon - Server management daemon for the AOServ Platform.
 * Copyright (C) 2000-2013, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2024  AO Industries, Inc.
 *     support@aoindustries.com
 *     7262 Bull Pen Cir
 *     Mobile, AL 36695
 *
 * This file is part of aoserv-daemon.
 *
 * aoserv-daemon is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * aoserv-daemon is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with aoserv-daemon.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.aoindustries.aoserv.daemon.email;

import com.aoapps.encoding.ChainWriter;
import com.aoapps.io.posix.PosixFile;
import com.aoapps.io.posix.Stat;
import com.aoapps.net.InetAddress;
import com.aoapps.net.Port;
import com.aoapps.tempfiles.TempFile;
import com.aoapps.tempfiles.TempFileContext;
import com.aoindustries.aoserv.client.AoservConnector;
import com.aoindustries.aoserv.client.distribution.OperatingSystemVersion;
import com.aoindustries.aoserv.client.email.AttachmentBlock;
import com.aoindustries.aoserv.client.email.AttachmentType;
import com.aoindustries.aoserv.client.email.InboxAddress;
import com.aoindustries.aoserv.client.email.SpamAssassinMode;
import com.aoindustries.aoserv.client.linux.Group;
import com.aoindustries.aoserv.client.linux.GroupServer;
import com.aoindustries.aoserv.client.linux.PosixPath;
import com.aoindustries.aoserv.client.linux.Server;
import com.aoindustries.aoserv.client.linux.User;
import com.aoindustries.aoserv.client.linux.UserServer;
import com.aoindustries.aoserv.client.net.Bind;
import com.aoindustries.aoserv.daemon.AoservDaemon;
import com.aoindustries.aoserv.daemon.AoservDaemonConfiguration;
import com.aoindustries.aoserv.daemon.posix.linux.PackageManager;
import com.aoindustries.aoserv.daemon.util.BuilderThread;
import com.aoindustries.aoserv.daemon.util.DaemonFileUtils;
import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Builds the .procmailrc configurations.
 *
 * @author  AO Industries, Inc.
 */
// TODO: ROCKY_9_X86_64
public final class ProcmailManager extends BuilderThread {

  private static final Logger logger = Logger.getLogger(ProcmailManager.class.getName());

  /** Disable email attachment type blocks here. This should be moved to jilter, assuming we can make a faster implementation in Java. */
  public static final boolean EMAIL_ATTACHMENT_TYPES_ENABLED = false;

  /** The file that stores the procmail configuration. */
  public static final String PROCMAILRC = ".procmailrc";

  /** The old first 6 lines of an auto-generated procmailrc file. */
  public static final String OLD_AUTO_PROCMAILRC =
      "#\n"
          + "# This .procmailrc file was automatically generated by AutoresponderManager. As\n"
          + "# long as this comment remains in this file, any changes will be overwritten.\n"
          + "# Removing this comment will allow manual changes to this file, but all\n"
          + "# automated functionality will be disabled.\n"
          + "#\n";

  /** The first 6 lines of an auto-generated procmailrc file. */
  public static final String AUTO_PROCMAILRC =
      "#\n"
          + "# This .procmailrc file was automatically generated by ProcmailManager. As\n"
          + "# long as this comment remains in this file, any changes will be overwritten.\n"
          + "# Removing this comment will allow manual changes to this file, but all\n"
          + "# automated functionality will be disabled.\n"
          + "#\n";

  private static ProcmailManager procmailManager;

  private static final PosixFile cyrusDeliver = new PosixFile("/usr/lib/cyrus-imapd/deliver");

  /**
   * The minimum message size that will not be passed through spamc, since
   * scanning large messages is time consuming and will usually not be spam.
   * This may need to be tweaked if we start to see spam getting through that
   * are large messages.
   */
  private static final int SPAMC_SKIP_THRESHOLD = 1000000;

  private ProcmailManager() {
    // Do nothing
  }

  private static final Object rebuildLock = new Object();

  @Override
  @SuppressWarnings({"UseSpecificCatch", "BroadCatchBlock", "TooBroadCatch"})
  protected boolean doRebuild() {
    try {
      Server thisServer = AoservDaemon.getThisServer();
      OperatingSystemVersion osv = thisServer.getHost().getOperatingSystemVersion();
      int osvId = osv.getPkey();
      if (
          osvId != OperatingSystemVersion.CENTOS_5_I686_AND_X86_64
              && osvId != OperatingSystemVersion.CENTOS_7_X86_64
      ) {
        throw new AssertionError("Unsupported OperatingSystemVersion: " + osv);
      }

      synchronized (rebuildLock) {
        // Only build .procmailrc files when procmail package is installed
        if (PackageManager.getInstalledPackage(PackageManager.PackageName.PROCMAIL) != null) {
          Set<PosixFile> restorecon = new LinkedHashSet<>();
          try {
            final int uidMin = thisServer.getUidMin().getId();
            final int gidMin = thisServer.getGidMin().getId();

            String catPath;
            String bashPath;
            String sedPath;
            // Capture return-path header if needed
            if (osvId == OperatingSystemVersion.CENTOS_5_I686_AND_X86_64) {
              catPath = "/bin/cat";
              bashPath = "/bin/bash";
              sedPath = "/bin/sed";
            } else if (osvId == OperatingSystemVersion.CENTOS_7_X86_64) {
              catPath = "/usr/bin/cat";
              bashPath = "/usr/bin/bash";
              sedPath = "/usr/bin/sed";
            } else {
              throw new AssertionError("Unsupported OperatingSystemVersion: " + osv);
            }

            InetAddress spamcConnectAddress;
            Port spamcConnectPort;
              {
                final Bind spamdBind = SpamAssassinManager.getSpamdBind();
                if (spamdBind == null) {
                  spamcConnectAddress = null;
                  spamcConnectPort = null;
                } else {
                  spamcConnectAddress = spamdBind.getIpAddress().getInetAddress();
                  spamcConnectPort = spamdBind.getPort();
                  if (spamcConnectAddress.isUnspecified()) {
                    // Connect to primary IP when is unspecified
                    spamcConnectAddress = thisServer.getPrimaryIpAddress().getInetAddress();
                  }
                }
              }
            GroupServer mailLsg = thisServer.getLinuxServerGroup(Group.MAIL);
            if (mailLsg == null) {
              throw new SQLException("Unable to find GroupServer: " + Group.MAIL + " on " + thisServer.getHostname());
            }
            int mailGid = mailLsg.getGid().getId();

            ByteArrayOutputStream bout = new ByteArrayOutputStream();
            // Control the permissions of the deliver program, needs to be SUID to
            // Setting here because RPM updates will change permissions
            if (
                osvId == OperatingSystemVersion.CENTOS_5_I686_AND_X86_64
            // Note: CentOS 7 permissions now set at service start:
            // || osvId == OperatingSystemVersion.CENTOS_7_X86_64
            ) {
              Stat deliverStat = cyrusDeliver.getStat();
              if (deliverStat.getUid() != PosixFile.ROOT_UID || deliverStat.getGid() != mailGid) {
                cyrusDeliver.chown(PosixFile.ROOT_UID, mailGid);
                deliverStat = cyrusDeliver.getStat();
              }
              if (deliverStat.getMode() != 02755) {
                cyrusDeliver.setMode(02755);
              }
            }

            for (UserServer lsa : thisServer.getLinuxServerAccounts()) {
              if (lsa.getLinuxAccount().getType().isEmail()) {
                if (!isManual(lsa)) {
                  final PosixPath home = lsa.getHome();
                  final PosixFile procmailrc = new PosixFile(home.toString(), PROCMAILRC);

                  // Stat for use below
                  final Stat procmailrcStat = procmailrc.getStat();
                  final boolean isAutoresponderEnabled = lsa.isAutoresponderEnabled();
                  List<AttachmentBlock> eabs;
                  if (EMAIL_ATTACHMENT_TYPES_ENABLED) {
                    eabs = lsa.getEmailAttachmentBlocks();
                  } else {
                    eabs = Collections.emptyList();
                  }
                  String spamAssassinMode = lsa.getEmailSpamAssassinIntegrationMode().getName();
                  // Build the file in RAM, first
                  bout.reset();
                  try (ChainWriter out = new ChainWriter(bout)) {
                    out.print(
                        AUTO_PROCMAILRC
                            + "\n"
                            + "# Setup the environment\n"
                            + "SHELL=").print(bashPath).print("\n");

                    // TODO: Build the file after this in advance, look for the longest line, and set accordingly.
                    //+ "LINEBUF=16384\n"
                    // This was only set for the auto-reply and email attachment block stuff.

                    // Default locking time is fine since not locking for spamassassin now: + "LOCKSLEEP=15\n");

                    User la = lsa.getLinuxAccount();
                    User.Name username = la.getUsername_id();
                    InboxAddress laa = lsa.getAutoresponderFrom();
                    List<InboxAddress> addresses = lsa.getLinuxAccAddresses();

                    // The same X-Loop is used for attachment filters and autoresponders
                    String xloopAddress = username + "@" + lsa.getServer().getHostname();

                    // Split the username in to user and domain (used by Cyrus)
                    String user;
                    String domain;
                      {
                        String usernameStr = username.toString();
                        int atPos = usernameStr.indexOf('@');
                        if (atPos == -1) {
                          user = usernameStr;
                          domain = "default";
                        } else {
                          user = usernameStr.substring(0, atPos);
                          domain = usernameStr.substring(atPos + 1);
                        }
                      }

                    // The default from address
                    String defaultFromAddress;
                    if (laa != null) {
                      defaultFromAddress = laa.getEmailAddress().toString();
                    } else {
                      if (addresses.size() >= 1) {
                        defaultFromAddress = addresses.get(0).getEmailAddress().toString();
                      } else {
                        defaultFromAddress = xloopAddress;
                      }
                    }

                    // Any X-Loop address is sent to the bit-bucket
                    out.print("\n"
                        + "# Discard any looped emails\n"
                        + ":0\n"
                        + "* ^X-Loop: ").print(xloopAddress).print("\n"
                        + "/dev/null\n");

                    if (!spamAssassinMode.equals(SpamAssassinMode.NONE)) {
                      if (spamcConnectAddress == null) {
                        throw new SQLException("SpamAssassin has no net_bind, but a UserServer has SpamAssassin integration enabled: " + lsa);
                      }

                      // Install SpamAssassin for /usr/bin/spamc
                      PackageManager.installPackage(PackageManager.PackageName.SPAMASSASSIN);

                      out.print("\n"
                          + "# Only use spamassassin if size less than " + SPAMC_SKIP_THRESHOLD + " bytes\n"
                          + ":0\n"
                          + "* < " + SPAMC_SKIP_THRESHOLD + "\n"
                          + "{\n"
                          + "  # Filter through spamassassin\n"
                          // procmail locking sucks and is not necessary: + "  :0 fw: spamassassin.lock\n"
                          + "  :0 fw\n"
                          + "  | /usr/bin/spamc -d ").print(spamcConnectAddress.toString());
                      assert spamcConnectPort != null;
                      int portNum = spamcConnectPort.getPort();
                      if (portNum != SpamAssassinManager.DEFAULT_SPAMD_PORT) {
                        out.print(" -p ").print(portNum);
                      }
                      out.print(" --connect-retries=6 --retry-sleep=10 --headers -s " + (SPAMC_SKIP_THRESHOLD * 2) + "\n"
                          + "  \n"
                          + "  # If spamassassin failed, return a temporary failure code to sendmail\n"
                          + "  :0\n"
                          + "  * !^X-Spam-Status: (Yes|No)\n"
                          + "  {\n"
                          + "    # Return EX_TEMPFAIL to have sendmail retry delivery\n"
                          + "    EXITCODE=75\n"
                          + "    HOST\n"
                          + "  }\n");
                      // Discard if configured to do so
                      int saDiscardScore = lsa.getSpamAssassinDiscardScore();
                      if (saDiscardScore > 0) {
                        out.print("\n"
                            + "  # Discard spam with a score >= ").print(saDiscardScore).print("\n"
                            + "  :0\n"
                            + "  * ^X-Spam-Level: ");
                        for (int c = 0; c < saDiscardScore; c++) {
                          out.print("\\*");
                        }
                        out.print("\n"
                            + "  /dev/null\n");
                      }
                      out.print("}\n");
                    }
                    // First figure out if this message will be rejected due to attachment
                    if (EMAIL_ATTACHMENT_TYPES_ENABLED && !eabs.isEmpty()) {
                      out.print("\n"
                          + "# Determine if the message contains ANY blocked attachments\n"
                          + ":0\n"
                          + "*^Content-Type: (multipart/.*|application/octet-stream)\n"
                          + "* HB ?? ^Content-(Type|Disposition): .*;.*($.*)?name=(\")?.*\\.");
                      if (eabs.size() >= 1) {
                        out.print('(');
                      }
                      for (int d = 0; d < eabs.size(); d++) {
                        if (d > 0) {
                          out.print('|');
                        }
                        out.print(eabs.get(d).getEmailAttachmentType().getExtension());
                      }
                      if (eabs.size() >= 1) {
                        out.print(')');
                      }
                      out.print("(\")?$\n"
                          + "{\n"
                          // Second, figure out the To address that was used, to be used as the From address
                          + "  # Figure out the from address\n"
                          + "  FROM=`/usr/bin/formail -xTo:`\n"
                          + "\n"
                          + "  # Figure out the subject\n"
                          + "  SUBJECT=`/usr/bin/formail -xSubject:`\n");

                      // Third, figure out the specific attachment that was rejected
                      if (eabs.size() == 1) {
                        AttachmentType eat = eabs.get(0).getEmailAttachmentType();
                        out.print("\n"
                            + "  # Only one extension, use these values\n"
                            + "  EXTENSIONS=\" ").print(eat.getExtension()).print("\"\n");
                      } else {
                        out.print("\n"
                            + "  # Build the list of disallowed extensions\n");
                        for (AttachmentBlock eab : eabs) {
                          String extension = eab.getEmailAttachmentType().getExtension();
                          out.print(
                              "  :0\n"
                                  + "  *^Content-Type: (multipart/.*|application/octet-stream)\n"
                                  + "  * HB ?? ^Content-(Type|Disposition): .*;.*($.*)?name=(\")?.*\\.").print(extension).print("(\")?$\n"
                              + "  {\n"
                              + "    EXTENSIONS=\"$EXTENSIONS ").print(extension).print("\"\n"
                              + "  }\n");
                        }
                      }
                      // Fourth, send the response
                      // TODO: Should we send these??? Should we put them in an IMAP folder?  Should we set the subject differently?
                      // Can we block these attachment types within sendmail at message acceptance time?
                      // MILTER!!!
                      out.print("\n"
                          + "  # Send the response message:\n"
                          + "  :0 h\n"
                          + "  | ( \\\n"
                          + "    /usr/bin/formail \\\n"
                          + "      -r \\\n"
                          + "      -i\"Subject: BLOCKED:$SUBJECT\" \\\n"
                          + "      -i\"From: $FROM\" \\\n"
                          + "      -A\"X-Loop: ").print(xloopAddress).print("\" ; \\\n"
                          + "      -i\"Precedence: junk\" ; \\\n"
                          + "      echo \"Your message has not been delivered because it contains at least one restricted\" ; \\\n"
                          + "      echo \"attachment.\" ; \\\n"
                          + "      echo \"\" ; \\\n"
                          + "      echo \"Recipient...........:$FROM\" ; \\\n"
                          + "      echo \"Subject.............:$SUBJECT\" ; \\\n"
                          + "      echo \"Detected Extensions.:$EXTENSIONS\" ; \\\n"
                          + "      echo \"\" ; \\\n"
                          + "      echo \"If you did not send this message, the most likely cause is a virus on another\" ; \\\n"
                          + "      echo \"computer.  The virus has used your email address as the from address.  As a\" ; \\\n"
                          + "      echo \"result, this automated response has been sent to you.\" ; \\\n"
                          + "      echo \"\" ; \\\n"
                          + "      echo \"Please scan your computer for viruses using the latest virus definitions.  If\" ; \\\n"
                          + "      echo \"you are unable to find any viruses then you were probably not the source of\" ; \\\n"
                          + "      echo \"this email and you may disregard this message.\" ; \\\n"
                          + "      echo \"\" ; \\\n"
                          + "      echo \"Blocked Attachment Types Include:\" ; \\\n"
                          + "      echo \"\" ; \\\n"
                          + "      echo \"    Extension   Description\" ; \\\n");
                      for (int d = 0; d < eabs.size(); d++) {
                        AttachmentType eat = eabs.get(d).getEmailAttachmentType();
                        String extension = eat.getExtension();
                        out.print("      echo \"    ").print(extension);
                        for (int e = extension.length(); e < 11; e++) {
                          out.print(' ');
                        }
                        out.print(' ').print(eat.getDescription());
                        out.print("\" ");
                        if (d < (eabs.size() - 1)) {
                          out.print("; ");
                        }
                        out.print("\\\n");
                      }
                      out.print("  ) | $SENDMAIL -oi -t -f\"$FROM\"\n"
                          + "}\n");
                    }

                    // Write the autoresponder if configured
                    if (isAutoresponderEnabled) {
                      // Figure out the autoresponder details
                      final String path = lsa.getAutoresponderPath();
                      final String subject = lsa.getAutoresponderSubject();
                      out.print("\n"
                          + "# Configure the autoresponder\n"
                          + ":0 h c\n"
                          + "* !^FROM_DAEMON\n"
                          + "* !^From: .*MAILER-DAEMON.*\n");
                      // This is already discarded above: + "* !^X-Loop: ").print(xloopAddress).print("\n");
                      // Don't respond to spam
                      if (!spamAssassinMode.equals(SpamAssassinMode.NONE)) {
                        // This handles both large messages that aren't scanned and those that are scanned by using !Yes
                        out.print("* !^X-Spam-Status: Yes\n");
                      }
                      // Note: /usr/bin/formail is provided by procmail package
                      out.print("| (/usr/bin/formail -r \\\n"
                          + "    -I\"Precedence: junk\" \\\n"
                          + "    -i\"From: ").print(defaultFromAddress).print("\" \\\n");
                      // TODO: What if subject has shell characters?
                      if (subject != null) {
                        out.print("    -i\"Subject: ").print(subject).print("\" \\\n");
                      }
                      out.print("    -A\"X-Loop: ").print(xloopAddress).print("\" ");
                      if (path == null) {
                        out.print("\\\n");
                      } else {
                        out.print("; \\\n"
                            + "    ").print(catPath).print(" ").print(path).print(" \\\n");
                      }
                      out.print(") | /usr/sbin/sendmail -oi -t -f\"").print(defaultFromAddress).print("\"\n");
                    }

                    if (lsa.useInbox()) {
                      // Capture return-path header if needed
                      // Make sure sed installed
                      PackageManager.installPackage(PackageManager.PackageName.SED);
                      out.print("\n"
                          + "# Capture the current Return-path to pass to deliver\n"
                          + ":0 h\n"
                          + "RETURN_PATH=| ").print(sedPath).print(" -n 's/^Return-Path: <\\(.*\\)>.*$/\\1/p' | /usr/bin/head -n 1\n");

                      // Only move to Junk folder when the inbox is enabled and in IMAP mode
                      if (spamAssassinMode.equals(SpamAssassinMode.IMAP)) {
                        out.print("\n"
                            + "# Place any flagged spam in the Junk folder\n"
                            + ":0\n"
                            + "* ^X-Spam-Status: Yes\n"
                            + "{\n"
                            + "  :0 w\n"
                            + "  | /usr/bin/tail -n +2 | ").print(cyrusDeliver.getPath()).print(" -a \"").print(user).print('@').print(domain)
                            .print("\" -r \"$RETURN_PATH\" \"").print(user).print("/Junk@").print(domain).print("\"\n"
                            + "\n"
                            + "  # Delivery failed, return EX_TEMPFAIL to have sendmail retry delivery\n"
                            + "  EXITCODE=75\n"
                            + "  HOST\n"
                            + "}\n");
                      }

                      // Deliver to INBOX
                      out.print("\n"
                          + ":0 w\n"
                          //+ "| /usr/bin/formail -I\"From \" | /usr/lib/cyrus-imapd/deliver -a \"").print(user).print('@').print(domain)
                          //.print("\" -r \"$RETURN_PATH\" \"").print(user).print('@').print(domain).print("\"\n");
                          + "| /usr/bin/tail -n +2 | ").print(cyrusDeliver.getPath()).print(" -a \"").print(user).print('@').print(domain)
                          .print("\" -r \"$RETURN_PATH\" \"").print(user).print('@').print(domain).print("\"\n"
                          + "\n"
                          + "# Delivery failed, return EX_TEMPFAIL to have sendmail retry delivery\n"
                          + "EXITCODE=75\n"
                          + "HOST\n");
                    } else {
                      // Discard the email if configured to not use the inbox or Junk folders
                      out.print("\n"
                          + "# Discard the message\n"
                          + ":0\n"
                          + "/dev/null\n");
                    }
                  }

                  // Write to disk if different than the copy on disk
                  byte[] newBytes = bout.toByteArray();
                  if (!procmailrcStat.exists() || !procmailrc.contentEquals(newBytes)) {
                    // Create the new autoresponder config
                    try (
                        TempFileContext tempFileContext = new TempFileContext(home.toString());
                        TempFile tempFile = tempFileContext.createTempFile(".procmailrc", null)
                        ) {
                      PosixFile tempPosixFile = new PosixFile(tempFile.getFile());
                      try (
                          FileOutputStream fout = tempPosixFile.getSecureOutputStream(
                              lsa.getUid().getId(),
                              lsa.getPrimaryLinuxServerGroup().getGid().getId(),
                              0600,
                              true,
                              uidMin,
                              gidMin
                          )
                          ) {
                        fout.write(newBytes);
                      }
                      tempPosixFile.renameTo(procmailrc);
                      restorecon.add(procmailrc);
                    }
                  }
                }
              }
            }
          } finally {
            DaemonFileUtils.restorecon(restorecon);
          }
        }
      }
      return true;
    } catch (ThreadDeath td) {
      throw td;
    } catch (Throwable t) {
      logger.log(Level.SEVERE, null, t);
      return false;
    }
  }

  /**
   * Determines if an existing procmail file is manually maintained.
   *
   * @exception  SQLException if the account is not an email type
   */
  public static boolean isManual(UserServer lsa) throws IOException, SQLException {
    // Must be an email type
    if (!lsa.getLinuxAccount().getType().isEmail()) {
      throw new SQLException("Not an email inbox: " + lsa.toString());
    }

    PosixPath home = lsa.getHome();
    // If the home directory is outside /home/, it is manually maintained (not maintained by this code)
    if (!home.toString().startsWith("/home/")) {
      return true;
    }

    PosixFile procmailrc = new PosixFile(home.toString(), PROCMAILRC);
    Stat procmailrcStat = procmailrc.getStat();

    boolean isManual;
    if (
        procmailrcStat.exists()
            && procmailrcStat.isRegularFile()
    ) {
      int len1 = AUTO_PROCMAILRC.length();
      StringBuilder sb = new StringBuilder(len1);
      int len2 = OLD_AUTO_PROCMAILRC.length();
      StringBuilder oldSb = new StringBuilder(len2);
      int longest = len1 >= len2 ? len1 : len2;
      // TODO: Secure open file, making sure no funny file permission stuff
      try (BufferedInputStream in = new BufferedInputStream(new FileInputStream(procmailrc.getFile()))) {
        int count = 0;
        int ch;
        while (count < longest && (ch = in.read()) != -1) {
          if (count < len1) {
            sb.append((char) ch);
          }
          if (count < len2) {
            oldSb.append((char) ch);
          }
          count++;
        }
      }
      isManual = !(sb.toString().equals(AUTO_PROCMAILRC) || oldSb.toString().equals(OLD_AUTO_PROCMAILRC));
    } else {
      isManual = false;
    }
    return isManual;
  }

  @SuppressWarnings("UseOfSystemOutOrSystemErr")
  public static void start() throws IOException, SQLException {
    Server thisServer = AoservDaemon.getThisServer();
    OperatingSystemVersion osv = thisServer.getHost().getOperatingSystemVersion();
    int osvId = osv.getPkey();

    synchronized (System.out) {
      if (
          // Nothing is done for these operating systems
          osvId != OperatingSystemVersion.CENTOS_5_DOM0_I686
              && osvId != OperatingSystemVersion.CENTOS_5_DOM0_X86_64
              && osvId != OperatingSystemVersion.CENTOS_7_DOM0_X86_64
              // Check config after OS check so config entry not needed
              && AoservDaemonConfiguration.isManagerEnabled(ProcmailManager.class)
              && procmailManager == null
      ) {
        System.out.print("Starting ProcmailManager: ");
        // Must be a supported operating system
        if (
            osvId == OperatingSystemVersion.CENTOS_5_I686_AND_X86_64
                || osvId == OperatingSystemVersion.CENTOS_7_X86_64
        ) {
          AoservConnector conn = AoservDaemon.getConnector();
          procmailManager = new ProcmailManager();
          if (EMAIL_ATTACHMENT_TYPES_ENABLED) {
            conn.getEmail().getAttachmentBlock().addTableListener(procmailManager, 0);
          }
          conn.getNet().getIpAddress().addTableListener(procmailManager, 0);
          conn.getLinux().getUserServer().addTableListener(procmailManager, 0);
          PackageManager.addPackageListener(procmailManager);
          System.out.println("Done");
        } else {
          System.out.println("Unsupported OperatingSystemVersion: " + osv);
        }
      }
    }
  }

  @Override
  public String getProcessTimerDescription() {
    return "Rebuild .procmailrc files";
  }
}
