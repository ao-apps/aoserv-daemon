/*
 * Copyright 2000-2013, 2015, 2016, 2017 by AO Industries, Inc.,
 * 7262 Bull Pen Cir, Mobile, Alabama, 36695, U.S.A.
 * All rights reserved.
 */
package com.aoindustries.aoserv.daemon.email;

import com.aoindustries.aoserv.client.AOServConnector;
import com.aoindustries.aoserv.client.AOServer;
import com.aoindustries.aoserv.client.BlackholeEmailAddress;
import com.aoindustries.aoserv.client.EmailAddress;
import com.aoindustries.aoserv.client.EmailDomain;
import com.aoindustries.aoserv.client.EmailForwarding;
import com.aoindustries.aoserv.client.EmailListAddress;
import com.aoindustries.aoserv.client.EmailPipeAddress;
import com.aoindustries.aoserv.client.LinuxAccAddress;
import com.aoindustries.aoserv.client.LinuxServerAccount;
import com.aoindustries.aoserv.client.OperatingSystemVersion;
import com.aoindustries.aoserv.client.SystemEmailAlias;
import com.aoindustries.aoserv.client.Username;
import com.aoindustries.aoserv.client.validator.UnixPath;
import com.aoindustries.aoserv.client.validator.UserId;
import com.aoindustries.aoserv.daemon.AOServDaemon;
import com.aoindustries.aoserv.daemon.AOServDaemonConfiguration;
import com.aoindustries.aoserv.daemon.LogFactory;
import com.aoindustries.aoserv.daemon.util.BuilderThread;
import com.aoindustries.aoserv.daemon.util.DaemonFileUtils;
import com.aoindustries.encoding.ChainWriter;
import com.aoindustries.io.IoUtils;
import com.aoindustries.io.unix.UnixFile;
import com.aoindustries.net.DomainName;
import com.aoindustries.util.StringUtility;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.logging.Level;

/**
 * @author  AO Industries, Inc.
 */
final public class EmailAddressManager extends BuilderThread {

	/**
	 * Sendmail files.
	 */
	private static final UnixFile
		aliases = new UnixFile("/etc/aliases"),
		userTable = new UnixFile("/etc/mail/virtusertable")
	;

	private static EmailAddressManager emailAddressManager;

	private EmailAddressManager() {
	}

	private static final Object rebuildLock = new Object();
	@Override
	protected boolean doRebuild() {
		try {
			AOServer thisAoServer = AOServDaemon.getThisAOServer();
			OperatingSystemVersion osv = thisAoServer.getServer().getOperatingSystemVersion();
			int osvId = osv.getPkey();
			if(
				osvId != OperatingSystemVersion.MANDRIVA_2006_0_I586
				&& osvId != OperatingSystemVersion.REDHAT_ES_4_X86_64
				&& osvId != OperatingSystemVersion.CENTOS_5_I686_AND_X86_64
			) throw new AssertionError("Unsupported OperatingSystemVersion: " + osv);

			int uid_min = thisAoServer.getUidMin().getId();
			int gid_min = thisAoServer.getGidMin().getId();

			synchronized(rebuildLock) {
				Set<UnixFile> restorecon = new LinkedHashSet<>();
				try {
					List<EmailAddress> eas=thisAoServer.getEmailAddresses();

					// Each username may only be used once within the aliases file
					Set<String> usernamesUsed=new HashSet<>();

					//
					// Write the new /etc/aliases file.
					//
					ByteArrayOutputStream aliasesBOut = new ByteArrayOutputStream();
					ByteArrayOutputStream usersBOut = new ByteArrayOutputStream();
					try (
						ChainWriter aliasesOut = new ChainWriter(aliasesBOut);
						ChainWriter usersOut = new ChainWriter(usersBOut)
					) {
						aliasesOut.print(
							"#\n"
								+ "#  Aliases in this file will NOT be expanded in the header from\n"
								+ "#  Mail, but WILL be visible over networks or from /bin/mail.\n"
								+ "#\n"
								+ "#       >>>>>>>>>>      The program \"newaliases\" must be run after\n"
								+ "#       >> NOTE >>      this file is updated for any changes to\n"
								+ "#       >>>>>>>>>>      show through to sendmail.\n"
								+ "#\n"
								+ "# Generated by "
						);
						aliasesOut.println(EmailAddressManager.class.getName());
						for(SystemEmailAlias alias : thisAoServer.getSystemEmailAliases()) {
							String address=alias.getAddress();
							usernamesUsed.add(address);
							aliasesOut.print(address).print(": ").println(alias.getDestination());
						}
						String ex_nouser;
						if(
							osvId==OperatingSystemVersion.REDHAT_ES_4_X86_64
							|| osvId==OperatingSystemVersion.CENTOS_5_I686_AND_X86_64
							) {
							//ex_nouser="/opt/aoserv-client/sbin/ex_nouser";
							ex_nouser="\"/bin/sh -c 'exit 67'\""; // Code for EX_NOUSER in /usr/include/sysexits.h
						} else throw new AssertionError("Unsupported OperatingSystemVersion: " + osv);
						for(LinuxServerAccount lsa : thisAoServer.getLinuxServerAccounts()) {
							String username=lsa.getLinuxAccount().getUsername().getUsername().toString();
							if(!usernamesUsed.contains(username)) {
								if(username.indexOf('@')==-1) {
									aliasesOut.print(username).print(": |").println(ex_nouser);
								}
								usernamesUsed.add(username);
							}
						}
						String[] devNullUsername=new String[1];
						Map<String,String> singleForwardingTies=new HashMap<>();
						Map<UnixPath,String> singleListTies=new HashMap<>();
						Map<String,String> singlePipeTies=new HashMap<>();
						Map<UserId,String> singleInboxTies=new HashMap<>();
						for(EmailAddress ea : eas) {
							String address=ea.getAddress();
							if(address.length()>0) {
								writeEmailAddressConfigs(
									ea,
									usernamesUsed,
									devNullUsername,
									singleForwardingTies,
									singleListTies,
									singlePipeTies,
									singleInboxTies,
									aliasesOut,
									usersOut
								);
							}
						}
						for(EmailDomain ed : thisAoServer.getEmailDomains()) {
							DomainName domain=ed.getDomain();
							if(ed.getEmailAddress("abuse")==null) usersOut.print("abuse@").print(domain).print("\tabuse\n");
							if(ed.getEmailAddress("devnull")==null) usersOut.print("devnull@").print(domain).print("\tdevnull\n");
							if(ed.getEmailAddress("mailer-daemon")==null) usersOut.print("mailer-daemon@").print(domain).print("\tmailer-daemon\n");
							if(ed.getEmailAddress("postmaster")==null) usersOut.print("postmaster@").print(domain).print("\tpostmaster\n");
						}
						for(EmailAddress ea : eas) {
							String address=ea.getAddress();
							if(address.length()==0) {
								writeEmailAddressConfigs(
									ea,
									usernamesUsed,
									devNullUsername,
									singleForwardingTies,
									singleListTies,
									singlePipeTies,
									singleInboxTies,
									aliasesOut,
									usersOut
								);
							}
						}
					}
					byte[] usersNewBytes = usersBOut.toByteArray();
					byte[] aliasesNewBytes = aliasesBOut.toByteArray();

					// Only write to disk if changed, this will almost always be the case when
					// tie usernames are used for any reason, but this will help for servers with
					// simple configurations.
					boolean needMakeMap = DaemonFileUtils.atomicWrite(
						userTable,
						usersNewBytes,
						0644,
						UnixFile.ROOT_UID,
						UnixFile.ROOT_GID,
						null,
						restorecon
					);
					boolean needNewAliases = DaemonFileUtils.atomicWrite(
						aliases,
						aliasesNewBytes,
						0644,
						UnixFile.ROOT_UID,
						UnixFile.ROOT_GID,
						null,
						restorecon
					);

					// SELinux before next steps
					DaemonFileUtils.restorecon(restorecon);
					restorecon.clear();

					// Rebuild the hash map
					if(needMakeMap) makeMap();

					// Call newaliases
					if(needNewAliases) newAliases();
				} finally {
					DaemonFileUtils.restorecon(restorecon);
				}
			}
			return true;
		} catch(ThreadDeath TD) {
			throw TD;
		} catch(Throwable T) {
			LogFactory.getLogger(EmailAddressManager.class).log(Level.SEVERE, null, T);
			return false;
		}
	}

	private static void writeEmailAddressConfigs(
		EmailAddress ea,
		Set<String> usernamesUsed,
		String[] devNullUsername,
		Map<String,String> singleForwardingTies,
		Map<UnixPath,String> singleListTies,
		Map<String,String> singlePipeTies,
		Map<UserId,String> singleInboxTies,
		ChainWriter aliasesOut,
		ChainWriter usersOut
	) throws IOException, SQLException {
		String address=ea.getAddress();
		DomainName domain=ea.getDomain().getDomain();

		/*
		 * The possible email deliveries:
		 *
		 * 1) /dev/null only
		 * 2) One forwarding destination, BEA ignored (use singleForwardingTies)
		 * 3) One email list, BEA ignored (use singleListTies)
		 * 4) One pipe, BEA ignored (use singlePipeTies)
		 * 5) One Inbox only, BEA ignored (use singleInboxTies)
		 * 6) Multiple destinations, BEA ignored (list each)
		 * 7) Nothing (ignore)
		 */
		BlackholeEmailAddress bea=ea.getBlackholeEmailAddress();
		List<EmailForwarding> efs=ea.getEmailForwardings();
		// We need to not forward email for disabled accounts, but do we just reject it instead?
		// List<EmailForwarding> efs=ea.getEnabledEmailForwardings();
		List<EmailListAddress> elas=ea.getEnabledEmailListAddresses();
		List<EmailPipeAddress> epas=ea.getEnabledEmailPipeAddresses();
		List<LinuxAccAddress> laas=ea.getLinuxAccAddresses();

		String tieUsername;

		// 1) /dev/null only
		if(
			bea!=null
			&& efs.isEmpty()
			&& elas.isEmpty()
			&& epas.isEmpty()
			&& laas.isEmpty()
		) {
			tieUsername=devNullUsername[0];
			if(tieUsername==null) {
				devNullUsername[0]=tieUsername=getTieUsername(usernamesUsed);
				aliasesOut.print(tieUsername).println(": /dev/null");
			}

		// 2) One forwarding destination, BEA ignored (use singleForwardingTies)
		} else if(
			efs.size()==1
			&& elas.isEmpty()
			&& epas.isEmpty()
			&& laas.isEmpty()
		) {
			String destination=efs.get(0).getDestination();
			tieUsername=singleForwardingTies.get(destination);
			if(tieUsername==null) {
				singleForwardingTies.put(destination, tieUsername=getTieUsername(usernamesUsed));
				aliasesOut.print(tieUsername).print(": ").println(destination);
			}

		// 3)  One email list, BEA ignored (use singleListTies)
		} else if(
			efs.isEmpty()
			&& elas.size()==1
			&& epas.isEmpty()
			&& laas.isEmpty()
		) {
			UnixPath path=elas.get(0).getEmailList().getPath();
			tieUsername=singleListTies.get(path);
			if(tieUsername==null) {
				singleListTies.put(path, tieUsername=getTieUsername(usernamesUsed));
				aliasesOut.print(tieUsername).print(": :include:").println(path);
			}

		// 4) One pipe, BEA ignored (use singlePipeTies)
		} else if(
			efs.isEmpty()
			&& elas.isEmpty()
			&& epas.size()==1
			&& laas.isEmpty()
		) {
			String command = epas.get(0).getEmailPipe().getCommand();
			tieUsername=singlePipeTies.get(command);
			if(tieUsername==null) {
				singlePipeTies.put(command, tieUsername=getTieUsername(usernamesUsed));
				aliasesOut.print(tieUsername).print(": \"| ").print(command).println('"');
			}

		// 5) One Inbox only, BEA ignored (use singleInboxTies)
		} else if(
			efs.isEmpty()
			&& elas.isEmpty()
			&& epas.isEmpty()
			&& laas.size()==1
		) {
			LinuxServerAccount lsa=laas.get(0).getLinuxServerAccount();
			if(lsa!=null) {
				Username un=lsa.getLinuxAccount().getUsername();
				if(un!=null) {
					UserId username=un.getUsername();
					tieUsername=singleInboxTies.get(username);
					if(tieUsername==null) {
						singleInboxTies.put(username, tieUsername=getTieUsername(usernamesUsed));
						aliasesOut.print(tieUsername).print(": \\").println(StringUtility.replace(username.toString(), '@', "\\@"));
					}
				} else tieUsername=null;
			} else tieUsername=null;

		// 6) Multiple destinations, BEA ignored (list each)
		} else if(
			!efs.isEmpty()
			|| !elas.isEmpty()
			|| !epas.isEmpty()
			|| !laas.isEmpty()
		) {
			tieUsername=getTieUsername(usernamesUsed);
			aliasesOut.print(tieUsername).print(": ");
			boolean done=false;
			for(EmailForwarding ef : efs) {
				if(done) aliasesOut.print(",\n\t");
				else done=true;
				aliasesOut.print(ef.getDestination());
			}
			for(EmailListAddress ela : elas) {
				if(done) aliasesOut.print(",\n\t");
				else done=true;
				aliasesOut.print(":include:").print(ela.getEmailList().getPath());
			}
			for(EmailPipeAddress epa : epas) {
				if(done) aliasesOut.print(",\n\t");
				else done=true;
				aliasesOut.print("\"| ").print(epa.getEmailPipe().getCommand()).print('"');
			}
			for(LinuxAccAddress laa : laas) {
				if(done) aliasesOut.print(",\n\t");
				else done=true;
				aliasesOut.print('\\').print(StringUtility.replace(laa.getLinuxServerAccount().getLinuxAccount().getUsername().getUsername().toString(),'@',"\\@"));
			}
			aliasesOut.println();

		// 7) Not used - ignore
		} else tieUsername=null;

		if(tieUsername!=null) usersOut.print(address).print('@').print(domain).print('\t').println(tieUsername);
	}

	private static final int TIE_USERNAME_DIGITS=12;
	private static final char[] tieChars={
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
		'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
	};
	private static String getTieUsername(Set<String> usernamesUsed) {
		Random random = AOServDaemon.getRandom();
		StringBuilder SB=new StringBuilder(4+TIE_USERNAME_DIGITS);
		SB.append("tmp_");
		while(true) {
			SB.setLength(4);
			for(int c=0;c<TIE_USERNAME_DIGITS;c++) SB.append(tieChars[random.nextInt(tieChars.length)]);
			String username=SB.toString();
			if(!usernamesUsed.contains(username)) {
				usernamesUsed.add(username);
				return username;
			}
		}
	}

	private static final Object makeMapLock=new Object();
	private static void makeMap() throws IOException, SQLException {
		synchronized(makeMapLock) {
			// Run the command
			String makemap;
			OperatingSystemVersion osv = AOServDaemon.getThisAOServer().getServer().getOperatingSystemVersion();
			int osvId = osv.getPkey();
			if(
				osvId == OperatingSystemVersion.MANDRIVA_2006_0_I586
				|| osvId == OperatingSystemVersion.REDHAT_ES_4_X86_64
				|| osvId == OperatingSystemVersion.CENTOS_5_I686_AND_X86_64
			) {
				makemap="/usr/sbin/makemap";
			} else throw new AssertionError("Unsupported OperatingSystemVersion: " + osv);

			String[] cmd = { makemap, "hash", userTable.getPath() };
			Process P = Runtime.getRuntime().exec(cmd);
			try {
				try (
					InputStream in = new BufferedInputStream(new FileInputStream(userTable.getPath()));
					OutputStream out = new BufferedOutputStream(P.getOutputStream())
				) {
					IoUtils.copy(in, out);
				}
			} finally {
				// Wait for the process to complete
				try {
					int retCode = P.waitFor();
					if(retCode!=0) throw new IOException("Non-zero return status: "+retCode);
				} catch (InterruptedException err) {
					LogFactory.getLogger(EmailAddressManager.class).log(Level.WARNING, null, err);
					// Restore the interrupted status
					Thread.currentThread().interrupt();
				}
			}

			// Check for error exit code
			int exit = P.exitValue();
			if (exit != 0) throw new IOException("Non-zero exit status: " + exit);
		}
	}

	public static void start() throws IOException, SQLException {
		AOServer thisAOServer = AOServDaemon.getThisAOServer();
		OperatingSystemVersion osv = thisAOServer.getServer().getOperatingSystemVersion();
		int osvId = osv.getPkey();

		synchronized(System.out) {
			if(
				// Nothing is done for these operating systems
				osvId != OperatingSystemVersion.CENTOS_5_DOM0_I686
				&& osvId != OperatingSystemVersion.CENTOS_5_DOM0_X86_64
				&& osvId != OperatingSystemVersion.CENTOS_7_DOM0_X86_64
				// Check config after OS check so config entry not needed
				&& AOServDaemonConfiguration.isManagerEnabled(EmailAddressManager.class)
				&& emailAddressManager == null
			) {
				System.out.print("Starting EmailAddressManager: ");
				// Must be a supported operating system
				if(
					osvId == OperatingSystemVersion.MANDRIVA_2006_0_I586
					|| osvId == OperatingSystemVersion.REDHAT_ES_4_X86_64
					|| osvId == OperatingSystemVersion.CENTOS_5_I686_AND_X86_64
				) {
					AOServConnector conn = AOServDaemon.getConnector();
					emailAddressManager = new EmailAddressManager();
					conn.getEmailDomains().addTableListener(emailAddressManager, 0);
					conn.getBlackholeEmailAddresses().addTableListener(emailAddressManager, 0);
					conn.getEmailAddresses().addTableListener(emailAddressManager, 0);
					conn.getEmailForwardings().addTableListener(emailAddressManager, 0);
					conn.getEmailLists().addTableListener(emailAddressManager, 0);
					conn.getEmailListAddresses().addTableListener(emailAddressManager, 0);
					conn.getEmailPipes().addTableListener(emailAddressManager, 0);
					conn.getEmailPipeAddresses().addTableListener(emailAddressManager, 0);
					conn.getLinuxServerAccounts().addTableListener(emailAddressManager, 0);
					conn.getLinuxAccAddresses().addTableListener(emailAddressManager, 0);
					conn.getPackages().addTableListener(emailAddressManager, 0);
					conn.getSystemEmailAliases().addTableListener(emailAddressManager, 0);
					System.out.println("Done");
				} else {
					System.out.println("Unsupported OperatingSystemVersion: " + osv);
				}
			}
		}
	}

	private static final Object newAliasesLock=new Object();
	private static void newAliases() throws IOException {
		synchronized(newAliasesLock) {
			// Run the command
			AOServDaemon.exec("/usr/bin/newaliases");
		}
	}

	@Override
	public String getProcessTimerDescription() {
		return "Rebuild Email Addresses";
	}
}
