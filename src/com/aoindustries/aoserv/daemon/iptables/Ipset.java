/*
 * 2012 by AO Industries, Inc.,
 * 7262 Bull Pen Cir, Mobile, Alabama, 36695, U.S.A.
 * All rights reserved.
 */
package com.aoindustries.aoserv.daemon.iptables;

import com.aoindustries.aoserv.client.IPAddress;
import com.aoindustries.aoserv.daemon.LogFactory;
import com.aoindustries.io.unix.UnixFile;
import com.aoindustries.lang.ProcessResult;
import java.io.BufferedReader;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.StringReader;
import java.io.StringWriter;
import java.nio.charset.Charset;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.logging.Level;

/**
 * Handles access to ipset.
 *
 * @author  AO Industries, Inc.
 */
final public class Ipset {

    public static final int MAX_IPSET_SIZE = 65535;

    public static final short HOST_NETWORK_PREFIX = 32;

    private static final String IPSET = "/sbin/ipset";

    private static final Charset CHARSET = Charset.forName("UTF-8");

    private static final String SAVE_COMMENT = "# Automatically generated by " + Ipset.class.getName() + "\n";

    /**
     * ipset has a global namespace.  To avoid name collisions with different
     * subsystems that use ipset, each subsystem has its own single character
     * prefix.
     */
    public enum NamespacePrefix {
        /**
         * Used by each IpReputationSet.
         *
         * @see  IpReputationSet
         */
        R
    }

    private Ipset() {
    }

    /**
     * To minimize the kernel locking duration, each ipset is only updated with
     * what has changed since the last build.
     */
    //private static final Map<IpReputationSet,Set<Integer>> lastNetworks=new HashMap<IpReputationSet,Set<Integer>>();

    /**
     * Calls ipset -S, skipping any comment lines
     *
     * @param  setName        the name of the set
     * @param  missingAsNull  when true, a missing set will be returned as null, otherwise will throw an exception
     */
    public static String save(String setName, boolean missingAsNull) throws IOException {
        ProcessResult result = ProcessResult.exec(
            new String[] {
                IPSET,
                "-S",
                setName
            },
            CHARSET
        );
        if(result.getExitVal()==0) {
            // Skip any comments
            BufferedReader in = new BufferedReader(new StringReader(result.getStdout()));
            try {
                StringWriter out = new StringWriter();
                try {
                    String line;
                    while((line=in.readLine())!=null) {
                        line = line.trim();
                        if(!line.startsWith("#")) {
                            out.write(line);
                            out.write('\n');
                        }
                    }
                } finally {
                    out.close();
                }
                return out.toString();
            } finally {
                in.close();
            }
        } else {
            String stderr = result.getStderr().trim();
            if(!missingAsNull || !stderr.endsWith("Unknown set")) throw new IOException("Non-zero exit value from " + IPSET + " -S: exitVal=" + result.getExitVal()+", stderr=" + stderr);
            return null;
        }
    }

    public static enum SetType {
        iphash
    }

    /**
     * Calls ipset -N
     */
    public static void create(String setName, SetType setType, String... options) throws IOException {
        String[] newCommand = new String[4 + options.length];
        newCommand[0] = IPSET;
        newCommand[1] = "-N";
        newCommand[2] = setName;
        newCommand[3] = setType.name();
        System.arraycopy(options, 0, newCommand, 4, options.length);
        ProcessResult result = ProcessResult.exec(newCommand, CHARSET);
        if(result.getExitVal()!=0) throw new IOException("Non-zero exit value from " + IPSET + " -N: exitVal=" + result.getExitVal()+", stderr=" + result.getStderr().trim());
    }

    /**
     * Calls ipset -D
     */
    public static void delete(String setName, int entry) throws IOException {
        ProcessResult result = ProcessResult.exec(
            new String[] {
                IPSET,
                "-D",
                setName,
                IPAddress.getIPAddressForInt(entry)
            },
            CHARSET
        );
        if(result.getExitVal()!=0) throw new IOException("Non-zero exit value from " + IPSET + " -D: exitVal=" + result.getExitVal()+", stderr=" + result.getStderr().trim());
    }

    /**
     * Calls ipset -A
     */
    public static void add(String setName, int entry) throws IOException {
        ProcessResult result = ProcessResult.exec(
            new String[] {
                IPSET,
                "-A",
                setName,
                IPAddress.getIPAddressForInt(entry)
            },
            CHARSET
        );
        if(result.getExitVal()!=0) throw new IOException("Non-zero exit value from " + IPSET + " -A: exitVal=" + result.getExitVal()+", stderr=" + result.getStderr().trim());
    }

    /**
     * Parses an ipset save file, returning the mutable set of IP addresses in order dumped.
     */
    public static void parse(String save, Set<Integer> entries) throws IOException {
        BufferedReader in = new BufferedReader(new StringReader(save));
        try {
            String line;
            while((line=in.readLine())!=null) {
                line = line.trim();
                if(line.startsWith("-A ")) {
                    int spacePos = line.indexOf(' ', 3);
                    if(spacePos==-1) throw new IOException("Unable to find second space");
                    entries.add(IPAddress. getIntForIPAddress(line.substring(spacePos+1)));
                }
            }
        } finally {
            in.close();
        }
    }

    /**
     * Synchronizes a single set to the expected entries, both in-kernel and on-disk versions.
     * Creates set in kernel if missing.
     * Adds/removes any necessary changes.
     * Updates on-disk only if missing or set modified.
     *
     * @param  entries        the ip or network entries, only the first <code>MAX_IPSET_SIZE</code> entries will be used
     * @param  networkPrefix  the network prefix or <code>HOST_NETWORK_PREFIX</code> for individual hosts
     * @param  setName        the set name used both in-kernel and on-disk
     * @param  setDir         the directory that stores the on-disk version
     */
    public static void synchronize(
        Set<Integer> entries,
        short networkPrefix,
        String setName,
        UnixFile setDir
    ) throws IOException {
        Set<Integer> unusedEntries;
        if(entries.size()>MAX_IPSET_SIZE) {
            LogFactory.getLogger(Ipset.class).log(
                Level.WARNING,
                "Only the first {0} entries used for ipset \"{1}\"",
                new Object[] {
                    MAX_IPSET_SIZE,
                    setName
                }
            );
            unusedEntries = new HashSet<Integer>((entries.size() - MAX_IPSET_SIZE) *4/3+1);
            int count = 0;
            for(Integer entry : entries) {
                if(count>=MAX_IPSET_SIZE) unusedEntries.add(entry);
                else count++;
            }
        } else {
            unusedEntries = Collections.emptySet();
        }

        // TODO: Cache values between passes for efficiency

        // Dump current set from kernel
        String save = save(setName, true);
        if(save==null) {
            // Create new set
            if(networkPrefix==HOST_NETWORK_PREFIX) {
                create(setName, SetType.iphash);
            } else {
                create(setName, SetType.iphash, "--netmask", Short.toString(networkPrefix));
            }

            // Dump new set
            save = save(setName, false);
        }

        // Will be set to true when re-dump is required
        boolean modified = false;

        // Parse current set, deleting any that should no longer exist, flagging as modified
        Set<Integer> existingEntries = new LinkedHashSet<Integer>(
            // Normally use 4/3+1, 5/3+1 here to leave room for 25% growth before any rehash
            entries.size() * 5/3 + 1
        );
        parse(save, existingEntries);
        Iterator<Integer> iter = existingEntries.iterator();
        while(iter.hasNext()) {
            Integer existing = iter.next();
            if(!entries.contains(existing) || unusedEntries.contains(existing)) {
                delete(setName, existing);
                iter.remove();
                modified = true;
            }
        }

        // Add any missing, flagging as modified
        for(Integer entry : entries) {
            if(!unusedEntries.contains(entry) && !existingEntries.contains(entry)) {
                add(setName, entry);
                modified = true;
            }
        }

        // Re-list if modified to get on-disk format
        if(modified) save = save(setName, false);

        // Add-in comment line about automatically generated
        save = SAVE_COMMENT + save;

        // Update on-disk storage if missing or changed
        UnixFile setFile    = new UnixFile(setDir, setName+".ipset",     true);
        byte[] contents = save.getBytes(CHARSET.name());
        if(
            !setFile.getStat().exists()
            || !setFile.contentEquals(contents)
        ) {
            // Create in new file
            UnixFile newSetFile = new UnixFile(setDir, setName+".ipset.new", true);
            OutputStream out = new FileOutputStream(newSetFile.getFile());
            try {
                out.write(contents);
            } finally {
                out.close();
                newSetFile.setMode(0600);
            }
            // Move over old file
            newSetFile.renameTo(setFile);
        }
    }
}
